<!DOCTYPE HTML>
<html>
<head>
    <title>OP1</title>
    <meta charset="utf-8">
    <script src="phaser262.min.js"></script>
</head>
<body>

    <div id="game"></div>

    <script type="text/javascript">
    
    var updateDelay = 0;

	var mainTop = 0;
	
	var canvasWidth = 400;
	var canvasHeight = 640;

	var mainOffsetX = 20;
	var mainOffsetY = 20;
	
	var gStep = 0;
	var gDir = "left";
	
	var mainWidth = canvasWidth - (mainOffsetX);
	var mainHeight = canvasHeight - (mainOffsetY);
	
	var gPoly;
	var graphics;
	var graphicsLine;
	var graphics2;
	var line1;
	var line2;
	
	var en1prevx;
	var en1prevy;
	var en1SpdX = 26;
	var en1SpdY = 26;
	var en1Size = 50;
	
	var traceArr = [];
	
	var gArr = [
	  [mainOffsetX, mainOffsetY],
	  [mainWidth, mainOffsetY],
	  [mainWidth, mainHeight],
	  [mainOffsetX, mainHeight]
	];
	
	var traceOpt = false;
	var en1Opt = false;
	var fsOpt = false;
	var areaOpt = false;
	
	if	(getParameterByName('trace')) {
		traceOpt = getParameterByName('trace');
	}
	if	(getParameterByName('en1')) {
		en1Opt = getParameterByName('en1');
	}
	if	(getParameterByName('fs')) {
		fsOpt = getParameterByName('fs');
	}
	if	(getParameterByName('area')) {
		areaOpt = getParameterByName('area');
	}
	
	
	
	//var gArr = [[20, 20],[380, 20],[380, 285],[261, 285],[261, 351],[380, 351],[380, 620],[20, 620]];
	
	//var gArr = [[20, 20],[380, 20],[380, 145],[292, 145],[292, 310],[380, 310],[380, 620],[20, 620]];
	//var gArr = [[20, 20],[380, 20],[380, 270],[263, 270],[263, 437],[380, 437],[380, 620],[20, 620]];
	/*
	var gArr = [
	  [40, 40],
	  [90, 40],
	  [90, 90],
	  [150, 90],
	  [150, 40],
	  [320, 40],
	  [320, 580],
	  [40, 580]
	];*/

    var game = new Phaser.Game(canvasWidth, canvasHeight, Phaser.AUTO, 'game');

    //  Our core Bullet class
    //  This is a simple Sprite object that we set a few properties on
    //  It is fired by all of the Weapon classes

    var Bullet = function (game, key) {

        Phaser.Sprite.call(this, game, 0, 0, key);

        this.texture.baseTexture.scaleMode = PIXI.scaleModes.NEAREST;

        this.anchor.set(0.5);

        this.checkWorldBounds = true;
        this.outOfBoundsKill = true;
        this.exists = false;

        this.tracking = false;
        this.scaleSpeed = 0;

    };

    Bullet.prototype = Object.create(Phaser.Sprite.prototype);
    Bullet.prototype.constructor = Bullet;

    Bullet.prototype.fire = function (x, y, angle, speed, gx, gy) {

        gx = gx || 0;
        gy = gy || 0;

        this.reset(x, y);
        this.scale.set(1);

        this.game.physics.arcade.velocityFromAngle(angle, speed, this.body.velocity);

        this.angle = angle;

        this.body.gravity.set(gx, gy);

    };

    Bullet.prototype.update = function () {

        if (this.tracking)
        {
            this.rotation = Math.atan2(this.body.velocity.y, this.body.velocity.x);
        }

        if (this.scaleSpeed > 0)
        {
            this.scale.x += this.scaleSpeed;
            this.scale.y += this.scaleSpeed;
        }

    };

    var Weapon = {};

    ////////////////////////////////////////////////////
    //  A single bullet is fired in front of the ship //
    ////////////////////////////////////////////////////

    Weapon.SingleBullet = function (game) {

        Phaser.Group.call(this, game, game.world, 'Single Bullet', false, true, Phaser.Physics.ARCADE);

        this.nextFire = 0;
        this.bulletSpeed = 600;
        this.fireRate = 100;

        for (var i = 0; i < 64; i++)
        {
            this.add(new Bullet(game, 'bullet5'), true);
        }

        return this;

    };

    Weapon.SingleBullet.prototype = Object.create(Phaser.Group.prototype);
    Weapon.SingleBullet.prototype.constructor = Weapon.SingleBullet;

    Weapon.SingleBullet.prototype.fire = function (source) {

        if (this.game.time.time < this.nextFire) { return; }

        var x = source.x + 10;
        var y = source.y + 10;

        this.getFirstExists(false).fire(x, y, 0, this.bulletSpeed, 0, 0);

        this.nextFire = this.game.time.time + this.fireRate;

    };

    /////////////////////////////////////////////////////////
    //  A bullet is shot both in front and behind the ship //
    /////////////////////////////////////////////////////////

    Weapon.FrontAndBack = function (game) {

        Phaser.Group.call(this, game, game.world, 'Front And Back', false, true, Phaser.Physics.ARCADE);

        this.nextFire = 0;
        this.bulletSpeed = 600;
        this.fireRate = 100;

        for (var i = 0; i < 64; i++)
        {
            this.add(new Bullet(game, 'bullet5'), true);
        }

        return this;

    };

    Weapon.FrontAndBack.prototype = Object.create(Phaser.Group.prototype);
    Weapon.FrontAndBack.prototype.constructor = Weapon.FrontAndBack;

    Weapon.FrontAndBack.prototype.fire = function (source) {

        if (this.game.time.time < this.nextFire) { return; }

        var x = source.x + 10;
        var y = source.y + 10;

        this.getFirstExists(false).fire(x, y, 0, this.bulletSpeed, 0, 0);
        this.getFirstExists(false).fire(x, y, 180, this.bulletSpeed, 0, 0);

        this.nextFire = this.game.time.time + this.fireRate;

    };

    //////////////////////////////////////////////////////
    //  3-way Fire (directly above, below and in front) //
    //////////////////////////////////////////////////////

    Weapon.ThreeWay = function (game) {

        Phaser.Group.call(this, game, game.world, 'Three Way', false, true, Phaser.Physics.ARCADE);

        this.nextFire = 0;
        this.bulletSpeed = 600;
        this.fireRate = 100;

        for (var i = 0; i < 96; i++)
        {
            this.add(new Bullet(game, 'bullet7'), true);
        }

        return this;

    };

    Weapon.ThreeWay.prototype = Object.create(Phaser.Group.prototype);
    Weapon.ThreeWay.prototype.constructor = Weapon.ThreeWay;

    Weapon.ThreeWay.prototype.fire = function (source) {

        if (this.game.time.time < this.nextFire) { return; }

        var x = source.x + 10;
        var y = source.y + 10;

        this.getFirstExists(false).fire(x, y, 270, this.bulletSpeed, 0, 0);
        this.getFirstExists(false).fire(x, y, 0, this.bulletSpeed, 0, 0);
        this.getFirstExists(false).fire(x, y, 90, this.bulletSpeed, 0, 0);

        this.nextFire = this.game.time.time + this.fireRate;

    };

    /////////////////////////////////////////////
    //  8-way fire, from all sides of the ship //
    /////////////////////////////////////////////

    Weapon.EightWay = function (game) {

        Phaser.Group.call(this, game, game.world, 'Eight Way', false, true, Phaser.Physics.ARCADE);

        this.nextFire = 0;
        this.bulletSpeed = 600;
        this.fireRate = 100;

        for (var i = 0; i < 96; i++)
        {
            this.add(new Bullet(game, 'bullet5'), true);
        }

        return this;

    };

    Weapon.EightWay.prototype = Object.create(Phaser.Group.prototype);
    Weapon.EightWay.prototype.constructor = Weapon.EightWay;

    Weapon.EightWay.prototype.fire = function (source) {

        if (this.game.time.time < this.nextFire) { return; }

        var x = source.x + 16;
        var y = source.y + 10;

        this.getFirstExists(false).fire(x, y, 0, this.bulletSpeed, 0, 0);
        this.getFirstExists(false).fire(x, y, 45, this.bulletSpeed, 0, 0);
        this.getFirstExists(false).fire(x, y, 90, this.bulletSpeed, 0, 0);
        this.getFirstExists(false).fire(x, y, 135, this.bulletSpeed, 0, 0);
        this.getFirstExists(false).fire(x, y, 180, this.bulletSpeed, 0, 0);
        this.getFirstExists(false).fire(x, y, 225, this.bulletSpeed, 0, 0);
        this.getFirstExists(false).fire(x, y, 270, this.bulletSpeed, 0, 0);
        this.getFirstExists(false).fire(x, y, 315, this.bulletSpeed, 0, 0);

        this.nextFire = this.game.time.time + this.fireRate;

    };

    ////////////////////////////////////////////////////
    //  Bullets are fired out scattered on the y axis //
    ////////////////////////////////////////////////////

    Weapon.ScatterShot = function (game) {

        Phaser.Group.call(this, game, game.world, 'Scatter Shot', false, true, Phaser.Physics.ARCADE);

        this.nextFire = 0;
        this.bulletSpeed = 600;
        this.fireRate = 40;

        for (var i = 0; i < 32; i++)
        {
            this.add(new Bullet(game, 'bullet5'), true);
        }

        return this;

    };

    Weapon.ScatterShot.prototype = Object.create(Phaser.Group.prototype);
    Weapon.ScatterShot.prototype.constructor = Weapon.ScatterShot;

    Weapon.ScatterShot.prototype.fire = function (source) {

        if (this.game.time.time < this.nextFire) { return; }

        var x = source.x + 16;
        var y = (source.y + source.height / 2) + this.game.rnd.between(-10, 10);

        this.getFirstExists(false).fire(x, y, 0, this.bulletSpeed, 0, 0);

        this.nextFire = this.game.time.time + this.fireRate;

    };

    //////////////////////////////////////////////////////////////////////////
    //  Fires a streaming beam of lazers, very fast, in front of the player //
    //////////////////////////////////////////////////////////////////////////

    Weapon.Beam = function (game) {

        Phaser.Group.call(this, game, game.world, 'Beam', false, true, Phaser.Physics.ARCADE);

        this.nextFire = 0;
        this.bulletSpeed = 1000;
        this.fireRate = 45;

        for (var i = 0; i < 64; i++)
        {
            this.add(new Bullet(game, 'bullet11'), true);
        }

        return this;

    };

    Weapon.Beam.prototype = Object.create(Phaser.Group.prototype);
    Weapon.Beam.prototype.constructor = Weapon.Beam;

    Weapon.Beam.prototype.fire = function (source) {

        if (this.game.time.time < this.nextFire) { return; }

        var x = source.x + 40;
        var y = source.y + 10;

        this.getFirstExists(false).fire(x, y, 0, this.bulletSpeed, 0, 0);

        this.nextFire = this.game.time.time + this.fireRate;

    };

    ///////////////////////////////////////////////////////////////////////
    //  A three-way fire where the top and bottom bullets bend on a path //
    ///////////////////////////////////////////////////////////////////////

    Weapon.SplitShot = function (game) {

        Phaser.Group.call(this, game, game.world, 'Split Shot', false, true, Phaser.Physics.ARCADE);

        this.nextFire = 0;
        this.bulletSpeed = 700;
        this.fireRate = 40;

        for (var i = 0; i < 64; i++)
        {
            this.add(new Bullet(game, 'bullet8'), true);
        }

        return this;

    };

    Weapon.SplitShot.prototype = Object.create(Phaser.Group.prototype);
    Weapon.SplitShot.prototype.constructor = Weapon.SplitShot;

    Weapon.SplitShot.prototype.fire = function (source) {

        if (this.game.time.time < this.nextFire) { return; }

        var x = source.x + 20;
        var y = source.y + 10;

        this.getFirstExists(false).fire(x, y, 0, this.bulletSpeed, 0, -500);
        this.getFirstExists(false).fire(x, y, 0, this.bulletSpeed, 0, 0);
        this.getFirstExists(false).fire(x, y, 0, this.bulletSpeed, 0, 500);

        this.nextFire = this.game.time.time + this.fireRate;

    };

    ///////////////////////////////////////////////////////////////////////
    //  Bullets have Gravity.y set on a repeating pre-calculated pattern //
    ///////////////////////////////////////////////////////////////////////

    Weapon.Pattern = function (game) {

        Phaser.Group.call(this, game, game.world, 'Pattern', false, true, Phaser.Physics.ARCADE);

        this.nextFire = 0;
        this.bulletSpeed = 600;
        this.fireRate = 40;

        this.pattern = Phaser.ArrayUtils.numberArrayStep(-800, 800, 200);
        this.pattern = this.pattern.concat(Phaser.ArrayUtils.numberArrayStep(800, -800, -200));

        this.patternIndex = 0;

        for (var i = 0; i < 64; i++)
        {
            this.add(new Bullet(game, 'bullet4'), true);
        }

        return this;

    };

    Weapon.Pattern.prototype = Object.create(Phaser.Group.prototype);
    Weapon.Pattern.prototype.constructor = Weapon.Pattern;

    Weapon.Pattern.prototype.fire = function (source) {

        if (this.game.time.time < this.nextFire) { return; }

        var x = source.x + 20;
        var y = source.y + 10;

        this.getFirstExists(false).fire(x, y, 0, this.bulletSpeed, 0, this.pattern[this.patternIndex]);

        this.patternIndex++;

        if (this.patternIndex === this.pattern.length)
        {
            this.patternIndex = 0;
        }

        this.nextFire = this.game.time.time + this.fireRate;

    };

    ///////////////////////////////////////////////////////////////////
    //  Rockets that visually track the direction they're heading in //
    ///////////////////////////////////////////////////////////////////

    Weapon.Rockets = function (game) {

        Phaser.Group.call(this, game, game.world, 'Rockets', false, true, Phaser.Physics.ARCADE);

        this.nextFire = 0;
        this.bulletSpeed = 400;
        this.fireRate = 250;

        for (var i = 0; i < 32; i++)
        {
            this.add(new Bullet(game, 'bullet10'), true);
        }

        this.setAll('tracking', true);

        return this;

    };

    Weapon.Rockets.prototype = Object.create(Phaser.Group.prototype);
    Weapon.Rockets.prototype.constructor = Weapon.Rockets;

    Weapon.Rockets.prototype.fire = function (source) {

        if (this.game.time.time < this.nextFire) { return; }

        var x = source.x + 10;
        var y = source.y + 10;

        this.getFirstExists(false).fire(x, y, 0, this.bulletSpeed, 0, -700);
        this.getFirstExists(false).fire(x, y, 0, this.bulletSpeed, 0, 700);

        this.nextFire = this.game.time.time + this.fireRate;

    };

    ////////////////////////////////////////////////////////////////////////
    //  A single bullet that scales in size as it moves across the screen //
    ////////////////////////////////////////////////////////////////////////

    Weapon.ScaleBullet = function (game) {

        Phaser.Group.call(this, game, game.world, 'Scale Bullet', false, true, Phaser.Physics.ARCADE);

        this.nextFire = 0;
        this.bulletSpeed = 800;
        this.fireRate = 100;

        for (var i = 0; i < 32; i++)
        {
            this.add(new Bullet(game, 'bullet9'), true);
        }

        this.setAll('scaleSpeed', 0.05);

        return this;

    };

    Weapon.ScaleBullet.prototype = Object.create(Phaser.Group.prototype);
    Weapon.ScaleBullet.prototype.constructor = Weapon.ScaleBullet;

    Weapon.ScaleBullet.prototype.fire = function (source) {

        if (this.game.time.time < this.nextFire) { return; }

        var x = source.x + 10;
        var y = source.y + 10;

        this.getFirstExists(false).fire(x, y, 0, this.bulletSpeed, 0, 0);

        this.nextFire = this.game.time.time + this.fireRate;

    };

    /////////////////////////////////////////////
    //  A Weapon Combo - Single Shot + Rockets //
    /////////////////////////////////////////////

    Weapon.Combo1 = function (game) {

        this.name = "Combo One";
        this.weapon1 = new Weapon.SingleBullet(game);
        this.weapon2 = new Weapon.Rockets(game);

    };

    Weapon.Combo1.prototype.reset = function () {

        this.weapon1.visible = false;
        this.weapon1.callAll('reset', null, 0, 0);
        this.weapon1.setAll('exists', false);

        this.weapon2.visible = false;
        this.weapon2.callAll('reset', null, 0, 0);
        this.weapon2.setAll('exists', false);

    };

    Weapon.Combo1.prototype.fire = function (source) {

        this.weapon1.fire(source);
        this.weapon2.fire(source);

    };

    /////////////////////////////////////////////////////
    //  A Weapon Combo - ThreeWay, Pattern and Rockets //
    /////////////////////////////////////////////////////

    Weapon.Combo2 = function (game) {

        this.name = "Combo Two";
        this.weapon1 = new Weapon.Pattern(game);
        this.weapon2 = new Weapon.ThreeWay(game);
        this.weapon3 = new Weapon.Rockets(game);

    };

    Weapon.Combo2.prototype.reset = function () {

        this.weapon1.visible = false;
        this.weapon1.callAll('reset', null, 0, 0);
        this.weapon1.setAll('exists', false);

        this.weapon2.visible = false;
        this.weapon2.callAll('reset', null, 0, 0);
        this.weapon2.setAll('exists', false);

        this.weapon3.visible = false;
        this.weapon3.callAll('reset', null, 0, 0);
        this.weapon3.setAll('exists', false);

    };

    Weapon.Combo2.prototype.fire = function (source) {

        this.weapon1.fire(source);
        this.weapon2.fire(source);
        this.weapon3.fire(source);

    };

    //  The core game loop

    var PhaserGame = function () {

        this.background = null;
        this.foreground = null;

        this.player = null;
        this.cursors = null;
        this.speed = 10;

        this.weapons = [];
        this.currentWeapon = 0;
        this.weaponName = null;
        
        this.mode = 0;
        this.turn = "down";
        
        var xPoints = [];
        var yPoints = [];
         
		for (var i = 0; i < gArr.length; i++) {
			xPoints.push(gArr[i][0]);
			yPoints.push(gArr[i][1]);
		}
		xPoints.push(gArr[0][0]);
		yPoints.push(gArr[0][1]);

		this.points = {
			'x': xPoints,
			'y': yPoints
		};

        this.pi = 0;
        this.path = [];

    };

    PhaserGame.prototype = {

        init: function () {

            this.game.renderer.renderSession.roundPixels = true;

            this.physics.startSystem(Phaser.Physics.ARCADE);

        },

        preload: function () {
        
        	if (!fsOpt) {
				this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
				this.game.scale.pageAlignHorizontally = true;
				this.game.scale.pageAlignVertically = true;
			}

            //  We need this because the assets are on Amazon S3
            //  Remove the next 2 lines if running locally
            // this.load.baseURL = 'http://files.phaser.io.s3.amazonaws.com/codingtips/issue007/';
            this.load.crossOrigin = 'anonymous';

            this.load.image('background', 'assets/back.png');
            this.load.image('foreground', 'assets/fore.png');
            this.load.image('player', 'assets/cr.png');
            this.load.spritesheet('en1', 'assets/en1.png');
            this.load.bitmapFont('shmupfont', 'assets/shmupfont.png', 'assets/shmupfont.xml');
            this.load.image('wall', 'assets/bullet11.png');
            this.load.image('trace', 'assets/bullet11.png');

            for (var i = 1; i <= 11; i++)
            {
                this.load.image('bullet' + i, 'assets/bullet' + i + '.png');
            }

            //  Note: Graphics are not for use in any commercial project

        },

        create: function () {

			//this.background = this.add.tileSprite(0, 0, this.game.width, this.game.height, 'background');
			//this.background.autoScroll(-40, 0);

			graphicsLine=game.add.graphics(0,0);
			graphics = game.add.graphics(0, 0);
			graphics2 =game.add.graphics(0,0);
           

			this.weapons.push(new Weapon.SingleBullet(this.game));
			this.weapons.push(new Weapon.FrontAndBack(this.game));
			this.weapons.push(new Weapon.ThreeWay(this.game));
			this.weapons.push(new Weapon.EightWay(this.game));
			this.weapons.push(new Weapon.ScatterShot(this.game));
			this.weapons.push(new Weapon.Beam(this.game));
			this.weapons.push(new Weapon.SplitShot(this.game));
			this.weapons.push(new Weapon.Pattern(this.game));
			this.weapons.push(new Weapon.Rockets(this.game));
			this.weapons.push(new Weapon.ScaleBullet(this.game));
			this.weapons.push(new Weapon.Combo1(this.game));
			this.weapons.push(new Weapon.Combo2(this.game));

			this.currentWeapon = 0;

			for (var i = 1; i < this.weapons.length; i++)
			{
				this.weapons[i].visible = false;
			}

			this.player = this.add.sprite(mainOffsetX, mainOffsetY, 'player');
			this.en1 =  this.add.sprite(mainWidth/2, mainHeight/2, 'en1');
			//this.en1 =  this.add.sprite(22, 618, 'en1');

			this.walls = this.game.add.group();
			this.traces = this.game.add.group();

			this.physics.arcade.enable(this.player);
			this.physics.arcade.enable(this.en1);

			// this.player.body.collideWorldBounds = true;
			this.en1.body.collideWorldBounds = true;
			//this.en1.body.velocity.setTo(250, 250);
			this.en1.body.velocity.setTo(150, 150);
			this.en1.body.bounce.set(1);

			this.bmd = this.add.bitmapData(this.game.width, this.game.height);
			this.bmd.addToWorld();

			//this.plot();

			//this.foreground = this.add.tileSprite(0, 0, this.game.width, this.game.height, 'foreground');
			// this.foreground.autoScroll(-60, 0);

			// this.weaponName = this.add.bitmapText(8, 364, 'shmupfont', "ENTER = Next Weapon", 24);
			
			this.areaTxt = this.add.bitmapText(8, 4, 'shmupfont', "100%", 15);

			game.input.onDown.add(this.gTap, this);

			//  Cursor keys to fly + space to fire
			this.cursors = this.input.keyboard.createCursorKeys();

			this.input.keyboard.addKeyCapture([ Phaser.Keyboard.SPACEBAR ]);

			var changeKey = this.input.keyboard.addKey(Phaser.Keyboard.ENTER);
			changeKey.onDown.add(this.nextWeapon, this);

        },
        
        gTap: function(pointer) {
				//this.weapons[this.currentWeapon].fire(this.player);
				
				var turnMin = 5;
				
				if (this.mode === 0)
                {
					var getDirNow = getStep (this.player.x ,this.player.y);
					//console.log(this.player.x + "::" + this.player.y + "::" + getDirNow[0] + "::" + getDirNow[1]);
				
			
				
					if (getDirNow[1] == "up") {
						this.mode ="right";
						this.turn = "up";
						this.player.angle = 270;
						var posArr = [this.player.x,this.player.y];
						traceArr.push(posArr);
					
					} else if (getDirNow[1] == "down") {
						this.mode ="left";
						this.turn = "up";
						this.player.angle = 270;
						var posArr = [this.player.x,this.player.y];
						traceArr.push(posArr);
					
					}  else if (getDirNow[1] == "left") {
						this.mode ="up";
						this.turn = "left";
						this.player.angle = 180;
						var posArr = [this.player.x,this.player.y];
						traceArr.push(posArr);
					
					}  else if (getDirNow[1] == "right") {
						this.mode ="down";
						this.turn = "left";
						this.player.angle = 180;
						var posArr = [this.player.x,this.player.y];
						traceArr.push(posArr);
					}
				
					//this.player.rotation = this.math.angleBetween(this.player.x,this.player.y,mainWidth/2,mainHeight/2);
				
				} else if (this.mode == "down") {
					/*alert("1::" + traceArr[traceArr.length-1][0] + ", " +traceArr[traceArr.length-1][1]);
					alert("2::" + this.player.x + ", " + this.player.y);
					alert("3::" + traceArr[traceArr.length-1][1] + ", " + this.player.y);
					alert("4::" + (Number(traceArr[traceArr.length-1][1])-Number(this.player.y)));*/
					if (Math.abs(traceArr[traceArr.length-1][1]-this.player.y)>turnMin) {
						this.mode = this.turn;
						this.turn = "up";
						this.player.angle = 270;
						var posArr = [this.player.x,this.player.y];
						traceArr.push(posArr);
					}
				} else if (this.mode == "up") {
					if (Math.abs(traceArr[traceArr.length-1][1]-this.player.y)>turnMin) {
						this.mode = this.turn;
						this.turn = "up";
						this.player.angle = 270;
						var posArr = [this.player.x,this.player.y];
						traceArr.push(posArr);
					}
				} else if (this.mode == "left") {
					if (Math.abs(traceArr[traceArr.length-1][0]-this.player.x)>turnMin) {
						this.mode = this.turn;
						this.turn = "left";
						this.player.angle = 180;
						var posArr = [this.player.x,this.player.y];
						traceArr.push(posArr);
					}
				} else if (this.mode == "right") {
					if (Math.abs(traceArr[traceArr.length-1][0]-this.player.x)>turnMin) {
						this.mode = this.turn;
						this.turn = "left";
						this.player.angle = 180;
						var posArr = [this.player.x,this.player.y];
						traceArr.push(posArr);
					}
					
				}
			},
			
			traceOverlap: function () {
				alert("Game over");
				location.reload();
				en1.destroy();
				
			},

        nextWeapon: function () {

            //  Tidy-up the current weapon
            if (this.currentWeapon > 9)
            {
                this.weapons[this.currentWeapon].reset();
            }
            else
            {
                this.weapons[this.currentWeapon].visible = false;
                this.weapons[this.currentWeapon].callAll('reset', null, 0, 0);
                this.weapons[this.currentWeapon].setAll('exists', false);
            }

            //  Activate the new one
            this.currentWeapon++;

            if (this.currentWeapon === this.weapons.length)
            {
                this.currentWeapon = 0;
            }

            this.weapons[this.currentWeapon].visible = true;

            this.weaponName.text = this.weapons[this.currentWeapon].name;

        },
        plot: function () {
        
        	xPoints = [];
       		yPoints = [];
         
			for (var i = 0; i < gArr.length; i++) {
				xPoints.push(gArr[i][0]);
				yPoints.push(gArr[i][1]);
			}
			xPoints.push(gArr[0][0]);
			yPoints.push(gArr[0][1]);

			this.points = {
				'x': xPoints,
				'y': yPoints
			};

            this.bmd.clear();

            this.path = [];

            var x = 1 / game.width;
            
            var prevpt;

            for (var i = 0; i <= 1; i += x)
            {
                if (this.mode === 0)
                {
                    var px = this.math.linearInterpolation(this.points.x, i);
                    var py = this.math.linearInterpolation(this.points.y, i);
                }
                else if (this.mode === 1)
                {
                    var px = this.math.bezierInterpolation(this.points.x, i);
                    var py = this.math.bezierInterpolation(this.points.y, i);
                }
                else if (this.mode === 2)
                {
                    var px = this.math.catmullRomInterpolation(this.points.x, i);
                    var py = this.math.catmullRomInterpolation(this.points.y, i);
                }

                //this.path.push( { x: px, y: py });

                this.bmd.rect(px, py, 1, 1, 'rgba(255, 255, 255, 1)');
                
                var node = { x: px, y: py, angle: 0 };

				if (i > 0)
				{
					node.angle = this.math.angleBetweenPoints(prevpt, node);
				}

				this.path.push(node);
				
				prevpt = node;
            }

            for (var p = 0; p < this.points.x.length; p++)
            {
                this.bmd.rect(this.points.x[p]-3, this.points.y[p]-3, 6, 6, 'rgba(255, 0, 0, 1)');
            }
            
           

        },
        drawtraceArr: function () {
			//draw out path from traceArr
			if (traceArr.length>0) {
				
				
				graphicsLine.lineStyle(2, 0xffd900, 1);
				graphicsLine.moveTo(traceArr[0][0],traceArr[0][1]);
				
				for (var i = 1; i < traceArr.length; i++) {
			
					 graphicsLine.lineTo(traceArr[i][0],traceArr[i][1]);
				}
				graphicsLine.lineTo(this.player.x,this.player.y);
				graphicsLine.endFill();
			} else {
				//alert("000");
			}
		},

        update: function () {

			updateDelay++;
			
			 
				//this.physics.arcade.collide(this.wall1, this.en1);
				//this.en1.body.velocity.x += 5;
				//this.player.body.velocity.set(0);

				//if (updateDelay % (7) == 0) {
					//user movement
					//this.player.body.velocity.x += 5;
				//}
				//if (updateDelay % (3) == 0) {

					//this.player.body.velocity.x = 5;

					/*this.player.x = this.path[this.pi].x;
					this.player.y = this.path[this.pi].y;

					this.pi++;

					if (this.pi >= this.path.length)
					{
						this.pi = 0;
					}
					this.player.rotation = this.path[this.pi].angle;
					console.log(this.player.rotation);*/
				//}
				
				graphicsLine.clear();
				graphics.clear();
				//graphics2.clear();
				
				var polyPoints = []
			
				for (var i = 0; i < gArr.length; i++)
				{
					polyPoints.push(gArr[i][0]);
					polyPoints.push(gArr[i][1]);
				}
			
				gPoly = new Phaser.Polygon(polyPoints);

				graphics.beginFill(0xCCCCCC, 0.3);
				graphics.drawPolygon(gPoly.points);
				graphics.endFill();
				
				var collSize = 1;
				
				
				
				
           
				this.player.anchor.set(0.5);

				this.en1.anchor.set(0.5);
				this.en1.angle +=4;
				
				if (updateDelay % (55) == 0) {
					if (this.mode=="down") {
						if (this.turn == "left") {
							this.turn = "right";
							this.player.angle = 0;
						} else {
							this.turn = "left";
							this.player.angle = 180;
						}
					} else if (this.mode=="up") {
						if (this.turn == "left") {
							this.turn = "right";
							this.player.angle = 0;
						} else {
							this.turn = "left";
							this.player.angle = 180;
						}
					} else if (this.mode=="left") {
						if (this.turn == "up") {
							this.turn = "down";
							this.player.angle = 90;
						} else {
							this.turn = "up";
							this.player.angle = 270;
						}
					} else if (this.mode=="right") {
						if (this.turn == "up") {
							this.turn = "down";
							this.player.angle = 90;
							
						} else {
							this.turn = "up";
							this.player.angle = 270;
						}
				
					}
				}
				var pSpd = 5;
				var pSpd2 = 1;
				
				if (updateDelay % (1) == 0) {
			
					if (this.mode === 0)
					{
						var getDirNow = getStep (this.player.x ,this.player.y);
						//console.log(this.player.x + "::" + this.player.y + "::" + getDirNow[0] + "::" + getDirNow[1]);
				
						if (getDirNow[1] == "up") {
							this.player.y -= pSpd;
							this.player.angle = 0;
							if (this.player.y < gArr[getDirNow[0]][1]) {
								this.player.y = gArr[getDirNow[0]][1];
							}
					
						} else if (getDirNow[1] == "down") {
							this.player.y += pSpd;
							this.player.angle = 180;
							if (this.player.y > gArr[getDirNow[0]][1]) {
								this.player.y = gArr[getDirNow[0]][1];
							}
					
						}  else if (getDirNow[1] == "left") {
							this.player.x -= pSpd;
							this.player.angle = 270;
							if (this.player.x < gArr[getDirNow[0]][0]) {
								this.player.x = gArr[getDirNow[0]][0];
							}
					
						}  else if (getDirNow[1] == "right") {
							this.player.x += pSpd;
							this.player.angle = 90;
							if (this.player.x > gArr[getDirNow[0]][0]) {
								this.player.x = gArr[getDirNow[0]][0];
							}
						}
				
						//this.player.rotation = this.math.angleBetween(this.player.x,this.player.y,mainWidth/2,mainHeight/2);
					
					} 
				}
				if (updateDelay % (1) == 0) {
				
					if (this.mode != 0)
					{
				 
						//if gMode is 1 and position not on wall advance in direction
						//if gMode is 1 and position touched wall, change mode to 0
					
						var preX = this.player.x;
						var preY = this.player.y;
						var nextX = this.player.x;
						var nextY = this.player.y;
		
						if (this.mode === "down") {
							nextY = this.player.y + pSpd2;
							//this.player.y += pSpd2;
							//this.drawtraceArr();
						} else if (this.mode === "up") {
							nextY = this.player.y - pSpd2;
							//this.player.y -= pSpd2;
							//this.drawtraceArr();
						} else if (this.mode === "left") {
							nextX = this.player.x - pSpd2;
							//this.player.x -= pSpd2;
							//this.drawtraceArr();
						} else if (this.mode === "right") {
							nextX = this.player.x + pSpd2;
							//this.player.x += pSpd2;
							//this.drawtraceArr();
						}
						
						var intFlag = -1;
							
						//check if player crosses any trace
						if (traceArr.length>1) {
							//console.log(Math.abs(traceArr[traceArr.length-1][0]-nextX) + ":::" + Math.abs(traceArr[traceArr.length-1][1]-nextY));
							
							var checkFlag = -1;
							
							if ((this.mode === "down")||(this.mode === "up")) {
								if (Math.abs(traceArr[traceArr.length-1][1]-nextY)>10) {
									checkFlag = 1;
								}
							} else if ((this.mode === "left")||(this.mode === "right")) {
								if (Math.abs(traceArr[traceArr.length-1][0]-nextX)>10) {
									checkFlag = 1;
								}
							}
							
							if (checkFlag == 1) {
							
								line1 = new Phaser.Line(preX, preY, nextX, nextY);
								for (var i = 1; i < traceArr.length; i++)
								{
									line2 = new Phaser.Line(traceArr[i-1][0], traceArr[i-1][1], traceArr[i][0], traceArr[i][1]);
									p = line1.intersects(line2, true);

									if (p) {
										intFlag = i;
									}
						
								}
							}
						
						}
						
						this.player.x = nextX;
						this.player.y = nextY;
						this.drawtraceArr();
						
						if (intFlag > -1) {
							if (traceOpt) {
								this.traceOverlap();
							}
						}
						
						
						//check all paths, if touch wall, park on border line and change mode
						if (!gPoly.contains(this.player.x, this.player.y)) {
								
							var intFlag = -1;
							line1 = new Phaser.Line(preX, preY, this.player.x, this.player.y);
							for (var i = 0; i < gArr.length; i++) {
						
								var pasti = i-1;
								if (i-1<0) {
									pasti=gArr.length-1;
								}
							
								line2 = new Phaser.Line(gArr[pasti][0], gArr[pasti][1], gArr[i][0], gArr[i][1]);
							
								p = line1.intersects(line2, true);

								if (p) {
									intFlag = i;
									this.mode = 0;
									this.player.x = p.x;
									this.player.y = p.y;
								
									//enter final insertion position 
									var posArr = [this.player.x,this.player.y];
									traceArr.push(posArr);
								
									//divide into 2 polygons and check size
								
									//get origin insertion point 1 path
									var tpath1 = getStep(traceArr[0][0],traceArr[0][1]);
				
									//get final insertion point 2 path
									var tpath2 = getStep(traceArr[traceArr.length-1][0],traceArr[traceArr.length-1][1]);
				
									var path1;
									var path2;
								
									//Set closer to path 0 point as first path
									if (tpath2[0]>tpath1[0]) {
										path1 = tpath1;
										path2 = tpath2;
					
									} else if (tpath2[0]<tpath1[0]) {
										path1 = tpath2;
										path2 = tpath1;
										traceArr = traceArr.reverse();
					
					
									} else if (tpath2[0]==tpath1[0]) {
										//check which came first
					
										path1 = tpath1;
										path2 = tpath2;
										//alert(path1[1]);
					
										//check path which is nearer to path point
										if (path1[1]=="up") {
											if (traceArr[0][1] < traceArr[traceArr.length-1][1]) {
												traceArr = traceArr.reverse();
											}
										} else if (path1[1]=="down") {
											if (traceArr[0][1] > traceArr[traceArr.length-1][1]) {
												traceArr = traceArr.reverse();
											}
										} else if (path1[1]=="left") {
											if (traceArr[0][0] < traceArr[traceArr.length-1][0]) {
												traceArr = traceArr.reverse();
											}
										} else if (path1[1]=="right") {
											//alert(traceArr[0][1] + ":::" + traceArr[traceArr.length-1][1]);
											if (traceArr[0][0] > traceArr[traceArr.length-1][0]) {
												traceArr = traceArr.reverse();
											}
										}
									}
								
									//create now pathArrs
									var newPathArr1 = [];
									var newPathArr2 = [];
				
									//create path array 1
									//Insert new paths starting from path 0
									//what if path 1 = 0?
									for (var i = 0; i < path1[0]; i++) {
										newPathArr1.push (gArr[i]);
									}
									//insert traceArr path
									for (var i = 0; i < traceArr.length; i++) {
										newPathArr1.push (traceArr[i]);
									}
									//insert paths after insertion point 2
									for (var i = path2[0]; i < gArr.length; i++) {
										newPathArr1.push (gArr[i]);
									}
				
									//create path array 2
									traceArr = traceArr.reverse();
				
									for (var i = (path1[0]); i < (path2[0]); i++) {
										newPathArr2.push (gArr[i]);
									}
									//insert traceArr path
									for (var i = 0; i < traceArr.length; i++) {
										newPathArr2.push (traceArr[i]);
									}
								
									//console.log(newPathArr1);
									//console.log(newPathArr2);
								
									var polyPoints = []
			
									for (var i = 0; i < newPathArr1.length; i++)
									{
										polyPoints.push(newPathArr1[i][0]);
										polyPoints.push(newPathArr1[i][1]);
									}
			
									gPoly = new Phaser.Polygon(polyPoints);
								
									if (gPoly.contains(this.en1.x, this.en1.y)) {
										gArr = [];
										for (var i = 0; i <  newPathArr1.length; i++) {
											gArr.push([newPathArr1[i][0],newPathArr1[i][1]]);
										}
									} else {
										gArr = [];
										for (var i = 0; i <  newPathArr2.length; i++) {
											gArr.push([newPathArr2[i][0],newPathArr2[i][1]]);
										}
									}
								
									traceArr = [];
									this.drawtraceArr();
								
								} else {
								
								}
							}
						
						}
					}
				}
				
				this.walls.removeAll(true);
				
				//create rectangle sprites for all the paths
				for (var i = 0; i < gArr.length; i++)
				{
					var pasti = i-1;
					if (i-1<0) {
						pasti=gArr.length-1;
					}
					//which position to use as start point?
					var startX = gArr[i][0];
					var startY = gArr[i][1];
					//if horizontal path
					if (gArr[i][0] - gArr[pasti][0]==0) {
						if (gArr[i][1]<gArr[pasti][1]) {
							//up
							//startY = gArr[i][1];
							startX -= collSize;
						} else {
							//down
							startY = gArr[pasti][1];
							//startX += collSize;
						}
					} else {
					//vertical
						if (gArr[i][0]>gArr[pasti][0]) {
							//right
							startX = gArr[pasti][0];
							startY -= collSize;
						} else {
							//left
							//startX = gArr[i][0];
							//startY += collSize;
						}
					}
					var wall1 =  this.add.sprite(startX, startY, 'wall');
					wall1.width = Math.max(Math.abs(gArr[i][0] - gArr[pasti][0]),collSize);
					wall1.height = Math.max(Math.abs(gArr[i][1] - gArr[pasti][1]),collSize);
					this.physics.arcade.enable(wall1);
					wall1.body.immovable = true;
					this.walls.add(wall1);
				}
				
				this.game.physics.arcade.collide(this.en1, this.walls);
				
				this.traces.removeAll(true);
				
				//create rectangle sprites for the trace
				if (traceArr.length>1) {
				
				
					for (var i = 1; i < traceArr.length; i++)
					{
						
						//which position to use as start point?
						var startX = traceArr[i][0];
						var startY = traceArr[i][1];
						//if horizontal path
						if (traceArr[i][0] - traceArr[i-1][0]==0) {
							if (traceArr[i][1]<traceArr[i-1][1]) {
								//up
								//startY = traceArr[i][1];
							} else {
								//down
								startY = traceArr[i-1][1];
							}
						} else {
						//vertical
							if (traceArr[i][0]>traceArr[i-1][0]) {
								//right
								startX = traceArr[i-1][0];
							} else {
								//left
								//startX = traceArr[i][0];
							}
						}
					
						var wall1 =  this.add.sprite(startX, startY, 'trace');
					
					
						wall1.width = Math.max(Math.abs(traceArr[i][0] - traceArr[i-1][0]),collSize);
						wall1.height = Math.max(Math.abs(traceArr[i][1] - traceArr[i-1][1]),collSize);
						this.physics.arcade.enable(wall1);
						wall1.body.immovable = true;
						//this.game.physics.arcade.overlap(wall1, this.traces, this.traceOverlap, null, this);   
						//this.game.physics.arcade.overlap(wall1, this.player, this.traceOverlap, null, this); 
						this.traces.add(wall1);
					}
				
				}
				
				//mark final wall
				if (traceArr.length>0) {
					//which position to use as start point?
					var dir1 = "up";
					var startX = this.player.x;
					var startY = this.player.y;
					//if horizontal path
					if (this.player.x - traceArr[traceArr.length-1][0]==0) {
						if (this.player.y<traceArr[traceArr.length-1][1]) {
							//up
							//startY = traceArr[i][1];
							
						} else {
							//down
							dir1 = "down";
							startY = traceArr[traceArr.length-1][1];
						}
					} else {
					//vertical
						if (this.player.x>traceArr[traceArr.length-1][0]) {
							//right
							dir1 = "right";
							startX = traceArr[traceArr.length-1][0];
						} else {
							//left
							dir1 = "left";
							//startX = traceArr[i][0];
						}
					}
				
					var wall1 =  this.add.sprite(startX, startY, 'trace');
				
					wall1.width = Math.max(Math.abs(this.player.x - traceArr[traceArr.length-1][0]),collSize);
					wall1.height = Math.max(Math.abs(this.player.y - traceArr[traceArr.length-1][1]),collSize);
					
					this.physics.arcade.enable(wall1);
					wall1.body.immovable = true;
					this.traces.add(wall1);
				}
				
				
			var polyPoints = []
		
			for (var i = 0; i < gArr.length; i++)
			{
				polyPoints.push(gArr[i][0]);
				polyPoints.push(gArr[i][1]);
			}
		
			gPoly = new Phaser.Polygon(polyPoints);
			this.en1.width = (en1Size * (gPoly.area/(mainWidth*mainHeight))) + (en1Size * 0.5);
			this.en1.height = this.en1.width;
			
			if (areaOpt) {
				if (gPoly.area/(mainWidth*mainHeight)<0.15) {
					alert("WIN!");
					location.reload();
					en1.destroy();
				}
			}
			
			if (!gPoly.contains(this.en1.x, this.en1.y)) {
				
				this.en1.body.reset(this.en1.body.prev.x, this.en1.body.prev.y);
				
				if (traceOpt) {
					this.traceOverlap();
				}
				
			}
			

            if (this.cursors.left.isDown)
            {
                this.player.body.velocity.x = -this.speed;
            }
            else if (this.cursors.right.isDown)
            {
                this.player.body.velocity.x = this.speed;
            }

            if (this.cursors.up.isDown)
            {
                this.player.body.velocity.y = -this.speed;
            }
            else if (this.cursors.down.isDown)
            {
                this.player.body.velocity.y = this.speed;
            }

            if (this.input.keyboard.isDown(Phaser.Keyboard.SPACEBAR))
            {
                this.weapons[this.currentWeapon].fire(this.player);
            }
            
            //this.game.physics.arcade.overlap(this.traces, this.traces, this.traceOverlap, null, this);   
			//this.game.physics.arcade.overlap(this.traces, this.player, this.traceOverlap, null, this);   
			if (en1Opt) {
				this.game.physics.arcade.overlap(this.traces, this.en1, this.traceOverlap, null, this);  
			}
				
				
            game.world.bringToTop(this.walls);
            game.world.bringToTop(this.traces);
            game.world.bringToTop(this.en1);
			game.world.bringToTop(this.player);
        }

    };

    game.state.add('Game', PhaserGame, true);

    
    function getStep(xIn, yIn) {
	
		//https://stackoverflow.com/questions/36523507/detection-and-response-ball-to-wall-collision-inside-any-polygon

		//console.log(">>>checkstep start");
		//console.log("xIn:" + xIn);
		//console.log("yIn:" + yIn);
	
		var dirNow= -1;
		//find out which step the point touches
		var stepNow = -1;
		//alert(stepNow);
		for (var i = 0; i < gArr.length; i++) {
			//console.log("check path: " + i);
		
			var pasti = i-1;
			if (i-1<0) {
				pasti=gArr.length-1;
			}
			
			var na1;
			var na2;
		
			//check x same or y same as prev point
			if (gArr[pasti][0]==gArr[i][0]) {
				//console.log("step with same X:" + gArr[pasti][0] );
				
				if (xIn==gArr[pasti][0]) {
					//console.log("gpiece with same X:" + xIn );
					
						na1 = gArr[i][1]; //higher - smaller
						na2 = gArr[pasti][1]; //lower - bigger
				
						if (gArr[pasti][1]>gArr[i][1]) {
							//na1 = gArr[i][1]; //higher - smaller
							//na2 = gArr[pasti][1]; //lower - bigger
							
							//dirNow = "up";
							
							//includes last point on the line
							if (yIn>na1 && yIn<=na2) {
								stepNow = i;
								dirNow = "up";
								//console.log("*found dir: " + dirNow);
								//console.log("match type up:" + i);
							} 
						
						} else {
							
							//na1 = gArr[i][1]; //lower - bigger
							//na2 = gArr[pasti][1]; //higher - smaller
							
							
							if (yIn>=na2 && yIn<na1) {
								stepNow = i;
								dirNow = "down";
								//console.log("*found dir: " + dirNow);
								//console.log("match type down:" + i);
							}
						}
						
						//console.log("y na1="+na1);
						//console.log("y na2="+na2);
					
				} else {
					//console.log("gpiece not with same X:" + xIn );
				}
			
			} else {
				//console.log("step with same Y" + gArr[pasti][1] + "," +  + gArr[i][1] );
			
				if (yIn==gArr[pasti][1]) {
					//console.log("gpiece with same Y:" + yIn );
					
					na1 = gArr[i][0];
					na2 = gArr[pasti][0];
			
						if (gArr[pasti][0]>gArr[i][0]) {
							//na1 = gArr[i][0];
							//na2 = gArr[pasti][0];
							
							
							
							
							if (xIn>na1 && xIn<=na2) {
								stepNow = i;
								dirNow = "left";
								//console.log("*found dir: " + dirNow);
							}
					
						} else {
							//na1 = gArr[i][0];
							//na2 = gArr[pasti][0];
							
							if (xIn<na1 && xIn>=na2) {
								stepNow = i;
								dirNow = "right";
								//console.log("*found dir: " + dirNow);
							}
						}
						
						//console.log("x na1="+na1);
						//console.log("x na2="+na2);
					
				} else {
					//console.log("gpiece not with same Y:" + yIn );
				}
				
			}
		}
		//console.log("*final dir: " + dirNow);
		var stepNowArr = [stepNow, dirNow];
		return stepNowArr;
	
	}
	
	function getParameterByName(name, url) {
		if (!url) url = window.location.href;
		name = name.replace(/[\[\]]/g, '\\$&');
		var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
			results = regex.exec(url);
		if (!results) return null;
		if (!results[2]) return '';
		return decodeURIComponent(results[2].replace(/\+/g, ' '));
	}

    </script>


</body>
</html>